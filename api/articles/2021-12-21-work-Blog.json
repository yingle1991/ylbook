{"title":"设计模式之一","slug":"2021-12-21-work-Blog","date":"2021-12-20T16:00:00.000Z","updated":"2021-12-24T09:31:43.738Z","comments":true,"path":"api/articles/2021-12-21-work-Blog.json","excerpt":"简单工厂模式定义严格意义简单工厂模式并非设计模式，比较像一种编码习惯。由于经常被使用，因此被大多数程序研发人员误认为是“工厂模式”。","covers":["https://gitee.com/yingle1991/resource/raw/master/static/blog/passme.png"],"content":"<ol>\n<li><p>简单工厂模式</p>\n<ul>\n<li><p>定义</p>\n<p>严格意义简单工厂模式并非设计模式，比较像一种编码习惯。由于经常被使用，因此被大多数程序研发人员误认为是“工厂模式”。</p>\n<a id=\"more\"></a> \n</li>\n<li><p>类图</p>\n<pre class=\"mermaid\">         classDiagram\n        PizzaStore --|> SimpleFactory\n        SimpleFactory --|>Pizza\n        Pizza <|.. CheesePizza\n        Pizza <|.. VeggiePizza\n        Pizza : +String name\n        Pizza : +String area\n        Pizza : +准备()\n        Pizza : +烘焙()\n        Pizza : +装饰()\n        Pizza : +打包()\n        class PizzaStore{\n                SimpleFactory factory\n            +Pizza OrderPizza()\n        }\n        class SimpleFactory{\n            +Pizza createPizza()\n        }\n        class CheesePizza{\n        }\n        class VeggiePizza{\n        }</pre>\n\n\n\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>解释</p>\n<p>适用于小作坊，包含多个具体产品，<br>SimpleFactory 就是生产产品的工厂，他应该是我们唯一用到具体Pizza类（CheesePizza、VeggiePizza）的地方。<br>PizzaStore 是工厂的客户，通过SimpleFactory 工厂取得Pizza实例。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>工厂方法模式</p>\n<ul>\n<li><p>定义<br>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。</p>\n</li>\n<li><p>类图</p>\n<pre class=\"mermaid\">         classDiagram\n        PizzaStore <|.. NYPizzaStore\n        PizzaStore <|.. ChinaPizzaStore\n        PizzaStore --|> Pizza\n        Pizza <|.. NYPizza\n        Pizza <|.. ChinaPizza\n        NYPizzaStore --|> NYPizza\n        ChinaPizzaStore --|>ChinaPizza\n        <&lt;abstract>> Pizza\n        Pizza : +String name\n        Pizza : +String area\n        Pizza : +准备()\n        Pizza : +烘焙()\n        Pizza : +装饰()\n        Pizza : +打包()\n        class PizzaStore{\n            +final OrderPizza()\n            +Pizza createPizza()\n        }\n        class NYPizzaStore{\n            +Pizza createPizza()\n        }\n        class ChinaPizzaStore{\n            +Pizza createPizza()\n        }\n\n        class NYPizza{\n\n        }\n        class ChinaPizza{\n        }</pre>\n\n\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>    ```</code></pre>\n<ul>\n<li>解释<br>   满足于连锁店，多个具体产品要适应多种地域特色，比如纽约的具体产品和中国的具体产品是味道是不一样的。<br>   抽象创建者（Creator）类  PizzaStore 定义了一个抽象的工厂方法 createPizza，让子类（具体创建者）实现此方法制造自己的产品，他通常包含依赖于抽象产品的代码，而这些抽象产品由子类制造，他并不需要真的知道 在制造哪种具体产品。<br>   工厂生产产品，对于创建者 PizzaStore来说，产品就是Pizza，他的子类是具体的产品，所有实际生产出来的Pizza 都是他的子类。</li>\n<li>优缺点<br>   解决了产品维度新增问题（新增具体产品的问题），只需要创建Pizza子类 ，并创建PizzaStore（创建者）的子类即可。</li>\n<li>引申 <ul>\n<li>依赖倒置原则（要依赖抽象，不要依赖具体类）<br>变量不可以持有具体类的引用<br>不要让类派生自具体类<br>不要覆盖基类中已实现的方法</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li><p>抽象工厂模式</p>\n<ul>\n<li><p>定义<br>  提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>\n</li>\n<li><p>类图</p>\n   <pre class=\"mermaid\">            classDiagram\n           PizzaStore <|.. NYPizzaStore\n           PizzaStore <|.. ChinaPizzaStore\n           PizzaStore --|> Pizza\n           Pizza <|.. ChinaPizza\n           Pizza <|.. NYPizza\n           NYPizzaStore --|> NYPizza\n           ChinaPizzaStore --|>ChinaPizza\n           <&lt;abstract>> Pizza\n           Pizza : +String name\n           Pizza : +String area\n           Pizza : +准备材料()\n           Pizza : +烘焙()\n           Pizza : +装饰()\n           Pizza : +打包()\n           class PizzaStore{\n                   <&lt;abstract>>\n               +final OrderPizza()\n               +Pizza createPizza()\n           }\n           class NYPizzaStore{\n               +Pizza createPizza()\n           }\n           class ChinaPizzaStore{\n               +Pizza createPizza()\n           }\n\n           class NYPizza{\n\n           }\n           class ChinaPizza{\n           }\n           NYPizzaIngredientFactory <|-- NYPizzaStore\n           class PizzaIngredientFactory{\n               <&lt;interface>>\n               +创建蘸酱\n               +创建面饼\n               +创建蔬菜\n               +创建肉\n               +创建芝士\n           }\n           PizzaIngredientFactory <|.. NYPizzaIngredientFactory\n           class NYPizzaIngredientFactory{\n               +创建蘸酱\n               +创建面饼\n               +创建蔬菜\n               +创建肉\n               +创建芝士\n           }\n           PizzaIngredientFactory <|.. ChinaPizzaIngredientFactory\n           class ChinaPizzaIngredientFactory{\n               +创建蘸酱\n               +创建面饼\n               +创建蔬菜\n               +创建肉\n               +创建芝士\n           }\n           蘸酱 <|.. 北京蘸酱\n           蘸酱 <|.. 纽约蘸酱\n           PizzaIngredientFactory --|>蘸酱\n           NYPizzaIngredientFactory --|>纽约蘸酱\n           ChinaPizzaIngredientFactory --|>北京蘸酱\n           NYPizza --|>蘸酱\n           class 蘸酱{\n               <&lt;interface>>    \n           }\n           面饼 <|.. 北京面饼\n           面饼 <|.. 纽约面饼\n           PizzaIngredientFactory --|>面饼\n           NYPizzaIngredientFactory --|>纽约面饼\n           ChinaPizzaIngredientFactory --|>北京面饼\n           NYPizza --|>面饼\n           class 面饼{\n               <&lt;interface>>    \n           }\n           芝士 <|.. 北京芝士\n           芝士 <|.. 纽约芝士\n           PizzaIngredientFactory --|>芝士\n           NYPizzaIngredientFactory --|>纽约芝士\n           ChinaPizzaIngredientFactory --|>北京芝士\n           NYPizza --|>芝士\n           NYPizza --|>PizzaIngredientFactory\n           class 芝士{\n               <&lt;interface>>    \n           }</pre>\n</li>\n<li><p>解释<br>NYPizzaStore 是抽象工厂的客户，负责创建Pizza 具体产品（NYPizza） ， 传入原料工厂的实例（NYPizzaIngredientFactory），工厂被要求准备原料。<br>PizzaIngredientFactory 是抽象的Pizza原料工厂接口，他定义了如何产生一个相关产品的家族，这个家族包含了所有制作Pizza的原料，子类负责生产Pizza原料，每个工厂都知道如何产生符合自己区域的正确产品，对于此产品家族，每个工厂都有不同的实现，ChinaPizzaIngredientFactory，生产 北京面饼、北京芝士、北京蘸酱。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>分享程序员的理财、生活！我是乐子，多多指教！</p>\n<ul>\n<li>EOF -<br><img src=\"https://gitee.com/yingle1991/resource/raw/master/static/blog/passme.png\" alt=\"关注我得到更多信息\"></li>\n</ul>\n","more":"</li>\n<li><p>类图</p>\n<pre class=\"mermaid\">         classDiagram\n        PizzaStore --|> SimpleFactory\n        SimpleFactory --|>Pizza\n        Pizza <|.. CheesePizza\n        Pizza <|.. VeggiePizza\n        Pizza : +String name\n        Pizza : +String area\n        Pizza : +准备()\n        Pizza : +烘焙()\n        Pizza : +装饰()\n        Pizza : +打包()\n        class PizzaStore{\n                SimpleFactory factory\n            +Pizza OrderPizza()\n        }\n        class SimpleFactory{\n            +Pizza createPizza()\n        }\n        class CheesePizza{\n        }\n        class VeggiePizza{\n        }</pre>\n\n\n\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>解释</p>\n<p>适用于小作坊，包含多个具体产品，<br>SimpleFactory 就是生产产品的工厂，他应该是我们唯一用到具体Pizza类（CheesePizza、VeggiePizza）的地方。<br>PizzaStore 是工厂的客户，通过SimpleFactory 工厂取得Pizza实例。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>工厂方法模式</p>\n<ul>\n<li><p>定义<br>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。</p>\n</li>\n<li><p>类图</p>\n<pre class=\"mermaid\">         classDiagram\n        PizzaStore <|.. NYPizzaStore\n        PizzaStore <|.. ChinaPizzaStore\n        PizzaStore --|> Pizza\n        Pizza <|.. NYPizza\n        Pizza <|.. ChinaPizza\n        NYPizzaStore --|> NYPizza\n        ChinaPizzaStore --|>ChinaPizza\n        <&lt;abstract>> Pizza\n        Pizza : +String name\n        Pizza : +String area\n        Pizza : +准备()\n        Pizza : +烘焙()\n        Pizza : +装饰()\n        Pizza : +打包()\n        class PizzaStore{\n            +final OrderPizza()\n            +Pizza createPizza()\n        }\n        class NYPizzaStore{\n            +Pizza createPizza()\n        }\n        class ChinaPizzaStore{\n            +Pizza createPizza()\n        }\n\n        class NYPizza{\n\n        }\n        class ChinaPizza{\n        }</pre>\n\n\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>    ```</code></pre>\n<ul>\n<li>解释<br>   满足于连锁店，多个具体产品要适应多种地域特色，比如纽约的具体产品和中国的具体产品是味道是不一样的。<br>   抽象创建者（Creator）类  PizzaStore 定义了一个抽象的工厂方法 createPizza，让子类（具体创建者）实现此方法制造自己的产品，他通常包含依赖于抽象产品的代码，而这些抽象产品由子类制造，他并不需要真的知道 在制造哪种具体产品。<br>   工厂生产产品，对于创建者 PizzaStore来说，产品就是Pizza，他的子类是具体的产品，所有实际生产出来的Pizza 都是他的子类。</li>\n<li>优缺点<br>   解决了产品维度新增问题（新增具体产品的问题），只需要创建Pizza子类 ，并创建PizzaStore（创建者）的子类即可。</li>\n<li>引申 <ul>\n<li>依赖倒置原则（要依赖抽象，不要依赖具体类）<br>变量不可以持有具体类的引用<br>不要让类派生自具体类<br>不要覆盖基类中已实现的方法</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li><p>抽象工厂模式</p>\n<ul>\n<li><p>定义<br>  提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>\n</li>\n<li><p>类图</p>\n   <pre class=\"mermaid\">            classDiagram\n           PizzaStore <|.. NYPizzaStore\n           PizzaStore <|.. ChinaPizzaStore\n           PizzaStore --|> Pizza\n           Pizza <|.. ChinaPizza\n           Pizza <|.. NYPizza\n           NYPizzaStore --|> NYPizza\n           ChinaPizzaStore --|>ChinaPizza\n           <&lt;abstract>> Pizza\n           Pizza : +String name\n           Pizza : +String area\n           Pizza : +准备材料()\n           Pizza : +烘焙()\n           Pizza : +装饰()\n           Pizza : +打包()\n           class PizzaStore{\n                   <&lt;abstract>>\n               +final OrderPizza()\n               +Pizza createPizza()\n           }\n           class NYPizzaStore{\n               +Pizza createPizza()\n           }\n           class ChinaPizzaStore{\n               +Pizza createPizza()\n           }\n\n           class NYPizza{\n\n           }\n           class ChinaPizza{\n           }\n           NYPizzaIngredientFactory <|-- NYPizzaStore\n           class PizzaIngredientFactory{\n               <&lt;interface>>\n               +创建蘸酱\n               +创建面饼\n               +创建蔬菜\n               +创建肉\n               +创建芝士\n           }\n           PizzaIngredientFactory <|.. NYPizzaIngredientFactory\n           class NYPizzaIngredientFactory{\n               +创建蘸酱\n               +创建面饼\n               +创建蔬菜\n               +创建肉\n               +创建芝士\n           }\n           PizzaIngredientFactory <|.. ChinaPizzaIngredientFactory\n           class ChinaPizzaIngredientFactory{\n               +创建蘸酱\n               +创建面饼\n               +创建蔬菜\n               +创建肉\n               +创建芝士\n           }\n           蘸酱 <|.. 北京蘸酱\n           蘸酱 <|.. 纽约蘸酱\n           PizzaIngredientFactory --|>蘸酱\n           NYPizzaIngredientFactory --|>纽约蘸酱\n           ChinaPizzaIngredientFactory --|>北京蘸酱\n           NYPizza --|>蘸酱\n           class 蘸酱{\n               <&lt;interface>>    \n           }\n           面饼 <|.. 北京面饼\n           面饼 <|.. 纽约面饼\n           PizzaIngredientFactory --|>面饼\n           NYPizzaIngredientFactory --|>纽约面饼\n           ChinaPizzaIngredientFactory --|>北京面饼\n           NYPizza --|>面饼\n           class 面饼{\n               <&lt;interface>>    \n           }\n           芝士 <|.. 北京芝士\n           芝士 <|.. 纽约芝士\n           PizzaIngredientFactory --|>芝士\n           NYPizzaIngredientFactory --|>纽约芝士\n           ChinaPizzaIngredientFactory --|>北京芝士\n           NYPizza --|>芝士\n           NYPizza --|>PizzaIngredientFactory\n           class 芝士{\n               <&lt;interface>>    \n           }</pre>\n</li>\n<li><p>解释<br>NYPizzaStore 是抽象工厂的客户，负责创建Pizza 具体产品（NYPizza） ， 传入原料工厂的实例（NYPizzaIngredientFactory），工厂被要求准备原料。<br>PizzaIngredientFactory 是抽象的Pizza原料工厂接口，他定义了如何产生一个相关产品的家族，这个家族包含了所有制作Pizza的原料，子类负责生产Pizza原料，每个工厂都知道如何产生符合自己区域的正确产品，对于此产品家族，每个工厂都有不同的实现，ChinaPizzaIngredientFactory，生产 北京面饼、北京芝士、北京蘸酱。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>分享程序员的理财、生活！我是乐子，多多指教！</p>\n<ul>\n<li>EOF -<br><img src=\"https://gitee.com/yingle1991/resource/raw/master/static/blog/passme.png\" alt=\"关注我得到更多信息\"></li>\n</ul>","categories":[],"tags":[{"name":"设计思路","path":"api/tags/设计思路.json"},{"name":"架构之路","path":"api/tags/架构之路.json"}]}